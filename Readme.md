## Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
    - добавлять строки в массив, потом объединить `strings.Join(strArr, "")`

### 2. Что такое интерфейсы, как они применяются в Go?
    - Тип интерфейса определяется как набор сигнатур методов.
    - Значение типа интерфейса может содержать любое значение, реализующее эти методы.
    - Может использоваться тогда, когда у разных структур схожая сигнатура методов, но разная имплементация

### 3. Чем отличаются RWMutex от Mutex?
    - RWMutex имеет методы RLock RUnlock - которые не блокируют друг друга на чтение, но ждут если есть блок на запись.
    - Mutex блокирует как на чтение так и на запись.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
    - буферизованный канал не ждет чтобы отправить данные, в отличие от буферизованного.

### 5. Какой размер у структуры struct{}{}?
    - Структура struct{}{} не занимает память, поскольку она не имеет полей. Размер такой структуры равен нулю.

### 6. Есть ли в Go перегрузка методов или операторов?
    - Нет, в Go нет поддержки перегрузки методов или операторов. В Go каждая функция или метод имеет уникальное имя и количество параметров, и вам не разрешено определять несколько функций или методов с одним и тем же именем, но разными параметрами.

### 7. В какой последовательности будут выведены элементы `map[int]int`?
    Пример:
        ```
        m[0]=1
        m[1]=124
        m[2]=281
        ```
    - Порядок вывода элементов map[int]int в Go является неопределенным. Размещение элементов в map основано на хеш-функции и может меняться, поэтому элементы могут быть выведены в произвольном порядке. Если нужно получить элементы map в определенном порядке, рекомендуется использовать срез для сортировки ключей или значений перед выводом.

### 8. В чем разница make и new?
    - В языке Golang оператор make используется для создания срезов (slices), отображений (maps) и каналов (channels), а оператор new используется для выделения памяти для указателей на типы данных. Разница между ними заключается в следующем:

    make: создает и инициализирует сложные типы данных, такие как срезы, отображения и каналы. Он выделяет память и инициализирует поля структуры в соответствии с требуемыми параметрами. Например:
    ```
    slice := make([]int, 5)    // Создает срез с длиной 5
    myMap := make(map[string]int)    // Создает пустое отображение
    channel := make(chan int)    // Создает канал
    ```
    new: выделяет память для указанного типа данных и возвращает указатель на него. В отличие от make, new не инициализирует значения переменных, а только выделяет память под них. Например:
    ```
    var myInt *int    // Объявление указателя на целое число
    myInt = new(int)    // Выделение памяти для указателя
    *myInt = 10    // Присвоение значения 10 указателю

    myStruct := new(MyStruct)    // Создание экземпляра структуры через указатель
    ```
    Таким образом, make используется для инициализации сложных типов данных, а new - для выделения памяти под указатели на типы данных.

### 9. Сколько существует способов задать переменную типа slice или map?
    - Существует несколько способов задать переменную типа slice или map:
    Инициализация пустого slice:
    ```
    var s []int
    s = make([]int, 0)
    // или сокращенная версия
    s := []int{}
    ```
    Инициализация slice с начальными значениями:
    `s := []int{1, 2, 3, 4, 5}`
    Инициализация slice с указанием емкости (количество элементов, которые могут быть сохранены в slice без реаллокации):
    `s := make([]int, 5, 10) // 5 - length, 10 - capacity`
    Инициализация map:
    `m := make(map[string]int)`
    Инициализация map с начальными значениями:
    ```
    m := map[string]int{
        "key1": 1,
        "key2": 2,
        "key3": 3,
    }
    ```
    Инициализация map с указанием емкости (количество элементов, которые могут быть сохранены в map без реаллокации):
    `m := make(map[string]int, 10)`

### 10. Что выведет данная программа и почему?
```
    func update(p *int) {
        b := 2
        p = &b
    }
    func main() {
        var (
        a = 1
        p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
    }
```
    - будет 1 1, потому что в функции update мы присвоили указателю p,
    адрес новой ячейки локально и не повлияли на значение в переменной a. 
    Но если сделать *p = a тогда ответ станет 1 2. 
    Потому что мы меняем само значение не создавая локальных копий.

### 11. Что выведет данная программа и почему?
    ```
    func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
    }
    ```
    - Выведет `fatal error: all goroutines are asleep - deadlock!`
    Потому что мы передали в ананимную горутину копии wg, а не указатель на одну wg.

### 12. Что выведет данная программа и почему?
    ```
    func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
    }
    ```
    - Выведет 0, так как в блоке if мы создали новую переменную n добавив := 1. В блоке if это локальная переменная
    и по выходу из этого блока, переменная n осталась прежней. Для изменений нужно не создавать а присваивать = без :

### 13. Что выведет данная программа и почему?
    ```
    func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
    }
    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
    }
    ```
    - В функции someAction обращение по индексу означает что мы изменяем само значение в памяти. А вызов append добавляет новое значение к локальной переменной v. Если передать в аргументах v *[]int8, тогда изменения будут видны.
    ```
    func someAction(v *[]int8, b int8) {
	x := *v
	x[0] = 100
	*v = append(*v, b)
    }
    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(&a, 6)
        fmt.Println(a)
    }
    ```
### 14. Что выведет данная программа и почему?
    ```
    func main() {
        slice := []string{"a", "a"}
        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
    }
    ```
    - Вывод: [b b a][a a]
    Так как мы сначала присвоили локальной копии append, а затем обратились по индексу, то обновились локальные значения по индексу. Если поменять местами присваивание индексам и операцию append, то будут видны изменения в изначальном slice.