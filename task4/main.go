package main

import (
	"bufio"
	"fmt"
	"os"
	"os/signal"
)

/* Задание 4
   Реализовать постоянную запись данных в канал (главный поток). Реализовать
   набор из N воркеров, которые читают произвольные данные из канала и
   выводят в stdout. Необходима возможность выбора количества воркеров при
   старте. Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать
   способ завершения работы всех воркеров.
*/

/* Решение
   	1) Мы создаем канал os.Signal размером 1,
       который принимает системную команду на завершение процесса Ctrl+C

	2) Получаем количество воркеров из стандартного ввода - fmt.Scan

	3) В цикле от 0 до кол-ва воркеров запускаем горутины которые слушают из главного канала mainCh

	4) Далее пишем в стандартный ввод и сканируем в другой горутине и пишем в главный канал

	5) Ожидаем получение сигнала команды завершения процесса.
	Здесь нам не нужно ждать завершение всех горутин так как в функции main,
	мы ожидаем получение сигнала команды завершения процесса. И так как операция получения из канала mainCh
	является атомарной, нам не нужно синхронизировать доступ к каналам для горутин.
*/

func main() {
	mainCh := make(chan interface{})
	signalChan := make(chan os.Signal, 1)
	var workers int
	fmt.Scan(&workers)
	for i := 0; i < workers; i++ {
		go func() {
			data, ok := <-mainCh
			if ok {
				fmt.Println(data)
			}
		}()
	}
	scan := bufio.NewScanner(os.Stdin)
	go func() {
		for scan.Scan() {
			mainCh <- scan.Text()
		}
	}()
	signal.Notify(signalChan, os.Interrupt)
	<-signalChan
}
